1. 索引发展历史:
    - 链表: 链式查找非常慢；
    - 哈希:
    - BST: 不平衡，深度越深，IO次数越多;
    - AVL与红黑树: 树平衡了，但在数据量很大时，
    深度依然很深，IO量依然很大
    - B树: 
        - 每个节点能够划分的数据比起二叉树更多，
        能够有效减少树深度从而减少IO次数；
        - 非叶子节点依然会存储一部分数据，导致每层
        能够存储的数据量偏少
    - B+ 树:
        - B树的基础上，增加了所有数据都存在叶子节点的限制
        - Innodb中，数据存储在索引文件中
        - Myisam中，数据存储在另外一个文件；而索引文件中的
        叶子存储的是指向数据响应位置的指针
        - 为什么一般B+ 树是三层？
            - 存储数据量问题；三层的B+ 树已经足够存储
            千万级别量级的数据
    
2. 一些关于索引的术语:
    - 回表: MySQL的表中，除了主键索引的其它索引文件，
    叶子节点存储的数据是对应的主键；再找到相应数据对应
    的主键之后，还需要回到主键索引中再进行一次查询找到
    数据
    - 覆盖索引: 指使用其它索引查找时，所需要的数据仅有
    主键，这样就可以避免回表
    - 最左匹配:
        - 在组合索引的条件下，比如 name + age
        - 查询 name + age 或 name 时，可以使用到这个组合索引
        - 查询 age 时，无法使用到这个组合索引
    - 索引下推:
        - 组合索引的条件下:
            - `select t1.name, t2.name from t1 join on t2 where t1.id = t2.id`
            - 两种查询方式:
                - 先将 t1 表的所有列与 t2 表的所有列根据id进行组合，再
                讲name列单独找出来
                - 先将 t1 表的 name/id 列与 t2 表的 name/id 列找出，
                再根据id进行组合得到结果
            - 很明显第二种查询方式涉及到的列更少，空间上节省了，速度也快了
            - 当有一个组合索引 name + age 时，
                - 传统的方法是在磁盘中将name先筛选一遍，将符合条件的name
                对应行load到内存，再把age筛选出来
                - 索引下推的方式，可以利用组合索引在磁盘上就直接完成
                name + age 的组合查找
                
3. 一些零碎知识点:
    - 当一个表没有设置主键时，MySQL等数据库会默认帮我们设置
    一个六位的`row_id`，在MYSQL种事不可见的；可以利用这个
    id来构建索引树
    - 数据库在创建表时，会创建唯一索引(包括主键索引)